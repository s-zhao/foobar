"""keep original models untouched such that when an applicationneeds additional specific care, a new proxy may be created.export PATH=$OPENSHIFT_DATA_DIR/bin:$PATH"""import decimal, uuidfrom django.db import modelsfrom django.db.models import F, Qfrom django.db.models.query import QuerySetfrom foobar.models import test## queryset provided custom query filters#class DodgeQuerySet(QuerySet):    def dodge2012(self):        return self.filter(car__year=2012, car__model__maker__name='DODGE')        def below_mrp(self):        return self.filter(price__lt = F('car__mrp'))        #    # queryset db write related methods    # ===============================================================================================    #    # from db.models.manager.py -    #    #   manager.'bulk_create', 'create', 'get_or_create', 'select_for_update', 'update'    #    # all dispatched to:    #    #   queryset.***    #    # queryset. - 'create', 'delete', '', 'update'    #    def create(self, *args, **kwargs):        """call instance init and save methods                so logic should go to model instance                per django doc, this is shorthand for            o = model(kwargs)            o.save()        """        print '@DodgeQuerySet.create'        return super(DodgeQuerySet, self).create(*args, **kwargs)    #    # batch operations    #            def update(self, *args, **kwargs):        """bypass instance's save method. so logic should go here ...                   apply update permission filter or pull records, update one by one        """        print '@DodgeQuerySet.update, count: ', self.count()        return super(DodgeQuerySet, self).update(*args, **kwargs)            def delete(self, *args, **kwargs):        """bypass instance's delete method, so logic should go here ...                   apply delete permission filter or pull records, delete one by one        """        print '@DodgeQuerySet.delete, count: ', self.count()        return super(DodgeQuerySet, self).delete(*args, **kwargs)        #    # disable them    #    def get_or_create(self, *args, **kwargs):        print '@DodgeQuerySet.get_or_create'        def bulk_create(self, *args, **kwargs):        print '@DodgeQuerySet.bulk_create'            def select_for_update(self, *args, **kwargs):        print '@DodgeQuerySet.select_for_update'            class DodgeDealerManager(models.Manager):    def get_query_set(self):        queryset = DodgeQuerySet(self.model)                #        # limit data to DODGE only        #        queryset = queryset.filter(car__model__maker__name='DODGE')                return queryset        class Registration(test.models.Registration):    class Meta:        proxy = True        dodge = DodgeDealerManager()             #    # instance methods    #    def __init__(self, *args, **kwargs):        super(Registration, self).__init__(*args, **kwargs)        if self.id:            print '@proxy.__init__ - pulling record - RECORD READ ACCESS RULES ...'        else:            print '@proxy.__init__ - creating record'            def save(self, *args, **kwargs):        if self.id:            print '@proxy.save - RECORD UPDATE RULES ..'        else:            print '@proxy.save - RECORD CREATION RULES ..'                return super(Registration, self).save(*args, **kwargs)            def delete(self, *args, **kwargs):        print '@proxy.delete - RECORD DELETION RULES ...'        return super(Registration, self).delete(*args, **kwargs)            def __unicode__(self):        return u'%s: %s %s' % (self.__class__, self.car.year, self.car.model.name)        def run():        #    # 'dodge' instead of 'objects' ...    #    # School.media    # School.cleveland.media ...    #    qset = Registration.dodge        print    print 'dodge count: ', qset.count()        assert qset.count() == test.models.Registration.objects.filter(car__model__maker__name='DODGE').count()    